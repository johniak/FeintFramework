<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FastCGI</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:AsyncSocket.AsyncSocketImpl.AsyncSocket-AsyncSocket-AsyncSendAll(System.Byte[])">
<summary>
 asynchronously send the given bytes; repeated sends until all done
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:AsyncSocket">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:BasicConnection.BasicConnection.Options">
<summary>
 access to global config options
</summary>
</member>
<member name="P:BasicConnection.BasicConnection.Closed">
<summary>
 Has this connection been closed actively? (not by the peer)
</summary>
</member>
<member name="">

</member>
<member name="M:BasicConnection.BasicConnection.SendRecord(Record.Record)">
<summary>
 Send a record to the web server (blocking)
</summary>
</member>
<member name="">

</member>
<member name="M:BasicConnection.BasicConnection.RecvRecord">
<summary>
 asynchronously reads a record from the socket
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:BasicConnection.BasicConnection.Close">
<summary>
 Close this connection.
 Used if web server sets FCGI_KEEP_CONN to false,
   i.e. connections should be closed after every request,
 or if a fatal error occured.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:BasicConnection">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Connection.Connection">
<summary>
 A connection as seen by Requests and Responses.
</summary>
</member>
<member name="T:Connection">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Cookies.Internal">

</member>
<member name="T:Cookies">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FastCGI.BindMode">
 <summary>How to listen to connections from the web server.
 <para>UseStdinSocket: try to use stdin as a socket (as described in the FastCGI spec and for example implemented by IIS)</para>
 <para>CreateSocket: create a new socket, as specified with the EndPoint property.</para>
 </summary>
</member>
<member name="">

</member>
<member name="T:FastCGI.LoggerDelegate">
<summary>
 A logging delegate type used for error logging and tracing.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FastCGI.Options.VariableEncoding(System.Text.UTF8Encoding)">
<summary>
 Text encoding of the variables in FastCGI records. Default: UTF8
</summary>
</member>
<member name="P:FastCGI.Options.TraceResponseHeaders(System.Boolean)">
<summary>
 Whether to print the response HTTP headers with TraceLogger.
</summary>
</member>
<member name="P:FastCGI.Options.TraceRequestHeaders(System.Boolean)">
<summary>
 Whether to print the received HTTP headers with TraceLogger.
</summary>
</member>
<member name="P:FastCGI.Options.TraceLogger(Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 A F# function that receives tracing information (for debugging).
</summary>
</member>
<member name="P:FastCGI.Options.OnTrace(FastCGI.LoggerDelegate)">
<summary>
 A delegate that receives tracing information (for debugging).
</summary>
</member>
<member name="P:FastCGI.Options.OnError(FastCGI.LoggerDelegate)">
<summary>
 A delegate that is executed with a string message whenever an unexpected error occurs.
</summary>
</member>
<member name="P:FastCGI.Options.ListenBacklog(System.Int32)">
<summary>
 Maximum listen backlog. See Socket.Listen documentation.
</summary>
</member>
<member name="P:FastCGI.Options.FCGI_MPXS_CONNS(System.String)">
<summary>
 What to reply to the server when it asks about FCGI_MPXS_CONNS (not implemented by most servers)
</summary>
</member>
<member name="P:FastCGI.Options.FCGI_MAX_REQS(System.String)">
<summary>
 What to reply to the server when it asks about FCGI_MAX_REQS (not implemented by most servers)
</summary>
</member>
<member name="P:FastCGI.Options.FCGI_MAX_CONNS(System.String)">
<summary>
 What to reply to the server when it asks about FCGI_MAX_CONNS (not implemented by most servers)
</summary>
</member>
<member name="P:FastCGI.Options.ErrorLogger(Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 A F# function that is called with a string message whenever an unexpected error occurs.
</summary>
</member>
<member name="P:FastCGI.Options.EndPoint(System.Net.IPEndPoint)">
<summary>
 Address and port of the socket if CreateSocket is chosen for Bind.
</summary>
</member>
<member name="P:FastCGI.Options.ConcurrentConnections(System.Boolean)">
<summary>
 Whether to allow multiple connections at the same time.
 Settings this to false can be useful if your handler code is not thread-safe, but makes it impossible
 to exploit concurrency even if the web server supports parallel connections.
</summary>
</member>
<member name="P:FastCGI.Options.CatchHandlerExceptions(System.Boolean)">
<summary>
 Whether to catch exceptions raised by client code (in the handler function)
</summary>
</member>
<member name="P:FastCGI.Options.Bind(FastCGI.BindMode)">
<summary>
 How to listen to connections from the web server.
 If this is set to CreateSocket, you MUST specify a value for EndPoint.
</summary>
</member>
<member name="P:FastCGI.Options.VariableEncoding">
<summary>
 Text encoding of the variables in FastCGI records. Default: UTF8
</summary>
</member>
<member name="P:FastCGI.Options.TraceResponseHeaders">
<summary>
 Whether to print the response HTTP headers with TraceLogger.
</summary>
</member>
<member name="P:FastCGI.Options.TraceRequestHeaders">
<summary>
 Whether to print the received HTTP headers with TraceLogger.
</summary>
</member>
<member name="P:FastCGI.Options.TraceLogger">
<summary>
 A F# function that receives tracing information (for debugging).
</summary>
</member>
<member name="P:FastCGI.Options.ListenBacklog">
<summary>
 Maximum listen backlog. See Socket.Listen documentation.
</summary>
</member>
<member name="P:FastCGI.Options.FCGI_MPXS_CONNS">
<summary>
 What to reply to the server when it asks about FCGI_MPXS_CONNS (not implemented by most servers)
</summary>
</member>
<member name="P:FastCGI.Options.FCGI_MAX_REQS">
<summary>
 What to reply to the server when it asks about FCGI_MAX_REQS (not implemented by most servers)
</summary>
</member>
<member name="P:FastCGI.Options.FCGI_MAX_CONNS">
<summary>
 What to reply to the server when it asks about FCGI_MAX_CONNS (not implemented by most servers)
</summary>
</member>
<member name="P:FastCGI.Options.ErrorLogger">
<summary>
 A F# function that is called with a string message whenever an unexpected error occurs.
</summary>
</member>
<member name="P:FastCGI.Options.EndPoint">
<summary>
 Address and port of the socket if CreateSocket is chosen for Bind.
</summary>
</member>
<member name="P:FastCGI.Options.ConcurrentConnections">
<summary>
 Whether to allow multiple connections at the same time.
 Settings this to false can be useful if your handler code is not thread-safe, but makes it impossible
 to exploit concurrency even if the web server supports parallel connections.
</summary>
</member>
<member name="P:FastCGI.Options.CatchHandlerExceptions">
<summary>
 Whether to catch exceptions raised by client code (in the handler function)
</summary>
</member>
<member name="P:FastCGI.Options.Bind">
<summary>
 How to listen to connections from the web server.
 If this is set to CreateSocket, you MUST specify a value for EndPoint.
</summary>
</member>
<member name="">

</member>
<member name="T:FastCGI.Options">
 <summary>Collection of configuration options for the FastCGI server.
 You should always at least specify a logging function (ErrorLogger (F#) or OnError(C#))
 and a Bind method.</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FastCGI.Request.Variables">
<summary>
 Request variables
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FastCGI.Request.Headers">
<summary>
 HTTP/1.1 headers sent by the user agent
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FastCGI.Request.Cookies">
<summary>
 Map of &apos;cookies&apos; provided by the user agent for this request.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FastCGI.Request.GetCookieValue(System.String)">
<summary>
 A convenience method; as &apos;getCookie&apos;, but returns only the value of the cookie
 rather than a &apos;Cookie&apos; object.
</summary>
</member>
<member name="">

</member>
<member name="T:FastCGI.Request">
<summary>
 Represents an HTTP request, including request variables, headers (incl. cookies) and
 the content data.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FastCGI.Response.ResponseStatus(System.Int32)">
 <summary>Sets and gets the response status which will be or has been sent with the response headers.</summary>
 <exception cref="HeadersAlreadySent">Thrown if the response headers have already been sent.</exception>
</member>
<member name="P:FastCGI.Response.ResponseStatus">
 <summary>Sets and gets the response status which will be or has been sent with the response headers.</summary>
 <exception cref="HeadersAlreadySent">Thrown if the response headers have already been sent.</exception>
</member>
<member name="P:FastCGI.Response.IsWritable">
<summary>
 Returns whether it is possible to write more data; ie, whether output has not
 yet been closed as by &apos;fCloseOutput&apos;.
</summary>
</member>
<member name="P:FastCGI.Response.Closed">
<summary>
 Whether the response is closed. See &apos;CloseOutput&apos;.
</summary>
</member>
<member name="M:FastCGI.Response.UnsetHeader(FastCGI.ResponseHeader)">
 <summary>Causes the given 'HttpHeader' response header not to be sent, overriding any value
 which has previously been set.
 <para>Does not prevent the 'HttpSetCookie' header from being sent if cookies have been
 set for this request with 'SetCookie'.</para>
 </summary>
 <exception cref="HeadersAlreadySent">If the response headers have already been sent</exception>
</member>
<member name="M:FastCGI.Response.UnsetCookie(System.String)">
 <summary>Causes the user agent to unset any cookie applicable to this page with the given name.
 <para>If an HttpCookie header is set for this request by a call to SetHeader, this function
 has not effect.</para></summary>
 <exception cref="HeadersAlreadySent">Thrown if the response headers have already been sent.</exception>
 <exception cref="CookieException">Thrown if the name is not valid.</exception>
</member>
<member name="M:FastCGI.Response.ToHttpDate(System.DateTime)">
<summary>
 Format a date according to &quot;RFC 822, updated by RFC 1123&quot;
</summary>
</member>
<member name="M:FastCGI.Response.SetHeader(FastCGI.ResponseHeader,System.String)">
 <summary>Sets the given 'HttpHeader' response header to the given string value, overriding
 any value which has previously been set.
 <para>The only headers set by default are "Status" (200) and "Content-Type" (text/html; charset=utf-8).</para>
 <para>If a value is set for the 'HttpSetCookie' header, this overrides all cookies set
 for this request with 'SetCookie' or 'UnsetCookie'.</para>
 </summary>
 <exception cref="HeadersAlreadySent">If the response headers have already been sent</exception>
</member>
<member name="M:FastCGI.Response.SetCookie(System.Net.Cookie)">
 <summary>Causes the user agent to record the given cookie and send it back with future loads of this page.
 The value will be put into quotes before it is sent to the client.
 <para>If an HttpCookie header is set for this request by a call to SetHeader, this function
 has not effect.</para></summary>
 <exception cref="HeadersAlreadySent">Thrown if the response headers have already been sent.</exception>
 <exception cref="CookieException">Thrown if the name is not valid.</exception>
</member>
<member name="M:FastCGI.Response.SendHeaders">
 <summary>Ensures that the response headers have been sent.  If they are already sent, does
 nothing.</summary>
 <exception cref="OutputAlreadyClosed">If output has already been closed</exception>
</member>
<member name="M:FastCGI.Response.SeeOtherRedirect(System.String)">
 <summary>Sets the HTTP/1.1 return status to 303 and sets the 'HttpLocation' header to
 the provided URL.</summary>
 <exception cref="HeadersAlreadySent">Thrown if the response headers have already been sent.</exception>
</member>
<member name="M:FastCGI.Response.PutStr(System.String)">
 <summary>Sends text, encoded as UTF-8.  This is the content data of the HTTP response.
 <para>If the response headers have not been sent, first sends them.</para>
 </summary>
 <exception cref="OutputAlreadyClosed">Thrown if output has already been closed</exception>
</member>
<member name="M:FastCGI.Response.Put(System.Byte[])">
 <summary>Sends data.  This is the content data of the HTTP response.
 <para>If the response headers have not been sent, first sends them.</para>
 </summary>
 <exception cref="OutputAlreadyClosed">Thrown if output has already been closed</exception>
</member>
<member name="M:FastCGI.Response.PermanentRedirect(System.String)">
 <summary>Sets the HTTP/1.1 return status to 301 and sets the 'HttpLocation' header to
 the provided URL.</summary>
 <exception cref="HeadersAlreadySent">Thrown if the response headers have already been sent.</exception>
</member>
<member name="M:FastCGI.Response.CloseOutput">
 <summary>Informs the web server and the user agent that the request has completed.
 <para>As a side-effect, any unread input is discarded and no more can be read.</para>
 <para>This is implicitly called, if it has not already been, after the handler returns; it
 may be useful within a handler if the handler wishes to return results and then
 perform time-consuming computations before exiting.</para>
 </summary>
 <exception cref="OutputAlreadyClosed">If output has already been closed</exception>
</member>
<member name="M:FastCGI.Response.AsyncSendHeaders">
 <summary>Ensures that the response headers have been sent.  If they are already sent, does
 nothing.</summary>
 <exception cref="OutputAlreadyClosed">If output has already been closed</exception>
</member>
<member name="M:FastCGI.Response.AsyncPutStr(System.String)">
 <summary>Asynchronously sends text, encoded as UTF-8.  This is the content data of the HTTP response.
 <para>If the response headers have not been sent, first sends them.</para>
 </summary>
 <exception cref="OutputAlreadyClosed">Thrown if output has already been closed</exception>
</member>
<member name="M:FastCGI.Response.AsyncPut(System.Byte[])">
 <summary>Asynchronously sends data.  This is the content data of the HTTP response.
 <para>If the response headers have not been sent, first sends them.</para>
 </summary>
 <exception cref="OutputAlreadyClosed">Thrown if output has already been closed</exception>
</member>
<member name="M:FastCGI.Response.AsyncCloseOutput">
 <summary>Asynchronously informs the web server and the user agent that the request has completed.
 See 'CloseOutput' for details.
 </summary>
</member>
<member name="">

</member>
<member name="T:FastCGI.Response">
<summary>
 Represents an HTTP response, including response status, headers and body.
 Provides both blocking and asynchronous methods.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FastCGI.Server.StartMultiplexing(FastCGI.RequestDelegate,FastCGI.Options)">
 <summary>Starts a multiplexing fastcgi server, executing 'handler' in a new worker thread for every request.
 <para>Does not return.</para>
 <para>Accepts connections concurrently and uses at least 2 threads per connection, unless configured otherwise.</para>
 <para>See Options type for configuration.</para>
 <para>Although no known web server implements fcgi multiplexing, using this method instead of 'Start' does improve performance
 in some scenarios.</para>
 </summary>
</member>
<member name="M:FastCGI.Server.Start(FastCGI.RequestDelegate,FastCGI.Options)">
 <summary>Starts a non-multiplexing fastcgi server, executing 'handler' for every request.
 <para>Does not return.</para>
 <para>Accepts connections concurrently and uses 1 thread per connection, unless configured otherwise.</para>
 <para>See Options type for configuration.</para>
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FastCGI.StreamBuffer.IsReadable">
<summary>
 Returns whether the input stream of the current request potentially has data
 remaining, either in the buffer or yet to be read.         
</summary>
</member>
<member name="M:FastCGI.StreamBuffer.GetContents">
 <summary>Reads all remaining data from the input stream of the current request, and
 interprets it as binary data.  This is the content data of the HTTP request, if any.
 <para>Blocks until all input has been read.</para>
 <para>If all input has been read, returns an empty array.</para>
 </summary>
 <exception cref="OutputAlreadyClosed">If CloseOutput of the current response has alread been called.</exception>
</member>
<member name="M:FastCGI.StreamBuffer.Get(System.Int32)">
 <summary>Reads up to a specified amount of data from the input stream of the current request,
 and interprets it as binary data. This is the content data of the HTTP request, if any.
 <para>If insufficient input is available, blocks until there is enough.</para>
 <para>If all input has been read, returns an empty array.</para>
 </summary>
 <exception cref="OutputAlreadyClosed">If CloseOutput of the current response has alread been called.</exception>
</member>
<member name="M:FastCGI.StreamBuffer.AsyncGetContents">
 <summary>Asynchronously reads all remaining data from the input stream of the current request, and
 interprets it as binary data.  This is the content data of the HTTP request, if any.
 See 'GetContents' for further details. </summary>
</member>
<member name="M:FastCGI.StreamBuffer.AsyncGet(System.Int32)">
 <summary>Asynchronously reads up to a specified amount of data from the input stream of the current request,
 and interprets it as binary data. This is the content data of the HTTP request, if any.
 See 'Get' for further details. </summary>
</member>
<member name="">

</member>
<member name="T:FastCGI.StreamBuffer">
 <summary>Encapsulates the Stdin buffer of a request, i.e. the content data.
 <para>Objects of this class are implicitely connected to a Response object (as dictated by the protocol).
 If the response has been closed,  it it no longer possible to read additional
 data from the request's Stdin stream.</para>
 Provides both blocking and asynchronous methods.
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FastCGI.FSharpInterface.startMultiplexingServer(FastCGI.Options,Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Request,Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Response,Microsoft.FSharp.Core.Unit}})">
<summary>
 Starts a server with a blocking handler and multiplexing connections; does not return.
</summary>
</member>
<member name="M:FastCGI.FSharpInterface.startServer(FastCGI.Options,Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Request,Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Response,Microsoft.FSharp.Core.Unit}})">
<summary>
 Starts a server, accepting a blocking handler function; does not return.
 Useful if you don&apos;t want to/can&apos;t write async handlers.
</summary>
</member>
<member name="">

</member>
<member name="M:FastCGI.FSharpInterface.multiplexingServerLoop(FastCGI.Options,Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Request,Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Response,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}})">
<summary>
 A server using multiplexing connections (at least two threads per connection).
 Not recommended unless you actually use a web server that supports multiplexing.
</summary>
</member>
<member name="M:FastCGI.FSharpInterface.serverLoop(FastCGI.Options,Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Request,Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Response,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}})">
<summary>
 A server using non-multiplexing connections (one thread per connection).
 Takes a non-blocking handler function to execute for every request.
 This is the preferred function to use from F# programs.
</summary>
</member>
<member name="T:FastCGI.FSharpInterface">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FastCGI.HeaderFunctions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FastCGI.OptionExt">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:MultiplexingConnection.MultiplexingConnection.RequestLoop(Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Request,Microsoft.FSharp.Core.FSharpFunc`2{FastCGI.Response,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}}})">
<summary>
 Reads records from the socket, manages request agents and delegates to them
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:MultiplexingConnection.MultiplexingConnection">
<summary>
 Implements request multiplexing (untested; did not find a web server
 that really used it)
 Uses a new mailbox processor as a worker for every request.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:MultiplexingConnection.RequestAgent.paramBuffer">
<summary>
 This buffer is built by and by when additional ParamRecord&apos;s arrive
 After the last ParamsRecord has been processed, it is null.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:MultiplexingConnection.RequestAgent.PostRecord">
<summary>
 Send a record to the agent to be processed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:MultiplexingConnection.RequestAgent">
<summary>
 Handles the records of one request.
</summary>
</member>
<member name="T:MultiplexingConnection">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:ProtocolConstants">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Record.VirtualRecord">
<summary>
 A record with content that is a part of a larger array, shared by multiple records.
 (A performance optimization)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Record.ContainedRecord">
<summary>
 A record that owns its own content array and that can be created from a byte stream.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Record.Record">
<summary>
 Represents a package of data received from or sent to the web server.
 A record usually belongs to a request (except for management records).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Record">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:ServerLoop.createListenSocket(FastCGI.Options)">
<summary>
 Try to create the listen socket according to the configured options.
</summary>
</member>
<member name="T:ServerLoop">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:SimpleConnection">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:SocketSupportDynamicWrapper.SocketSupport">
<summary>
 We wrap the access to this low level C++ assembly in
 a dynamic access layer, because it is only needed if
 a stdin socket is used for communication.
 Otherwise, we do not need the SocketSupport assembly at all.
 For documentation, see the C++/CLI project.
</summary>
</member>
<member name="T:SocketSupportDynamicWrapper">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:VariableEncoding">

</member>
</members>
</doc>
